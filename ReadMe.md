Демонстрация SOLID принципов

Цель: Практическое применение SOLID принципов.


Описание/Пошаговая инструкция выполнения домашнего задания:
На примере реализации игры «Угадай число» продемонстрировать практическое применение SOLID принципов.
Программа рандомно генерирует число, пользователь должен угадать это число. При каждом вводе числа программа пишет больше или меньше отгадываемого. Кол-во попыток отгадывания и диапазон чисел должен задаваться из настроек.
В отчёте написать, что именно сделано по каждому принципу.
Приложить ссылку на проект и написать, сколько времени ушло на выполнение задачи.

Что именно сделано по каждому принципу SOLID:

1. Single responsibility — принцип единственной ответственности - Каждый программный модуль должен иметь только одну причину для изменения

Классы и методы разделены по принципу единственной ответственности.
Логика разбита на несколько классов, каждый из которых реализует конкретный функционал.
Изменение каждого из классов потребуется только в том случае, если изменится логика самой функции которую реализует класс.

- DefaultGameBuilder - настраивает зависимости для IGame
- Game - отвечает за реализацию логики игрового цикла
- GameStateMachine - отвечает за управление текущего состояния игры
- TargetNumberService - отвечает за предоставление загаданного игрой числа
- GameView - отвечает за отображение информации в консоли и получение данных из консоли

2. Open-closed — принцип открытости / закрытости - Модули должны быть открыты для расширения, но закрыты для модификаций

Каждый класс реализован таким образом, что защищен от модификаций.

3. Liskov substitution — принцип подстановки Барбары Лисков - Производные классы должны быть доступны через интерфейс базового класса, при этом пользователю не обязательно знать разницу.

Принцип не нарушается, так как не применяется.

4. Interface segregation — принцип разделения интерфейса

Все интерфейсы реализованы таким образом, что нет необходимости разделять на более мелкие интерфейсы.

5. Dependency inversion — принцип инверсии зависимостей

Конструкторы каждого из реализованных классов принимают аргументы абстрактного типа вместо конкретного (например: Game, GameStateMachine).
За исключением тех классов которые зависят от GameSettings.